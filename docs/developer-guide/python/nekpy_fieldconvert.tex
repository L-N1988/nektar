\chapter{FieldConvert in NekPy}

This chapter describes how to emulate the functionality of the FieldConvert utility in Python using the bindings and wrappers created for the \verb+FieldUtils+ library.

%\section{Idea and motivation}

%The primary objective is to allow the user to execute a sequence of commands from a Python script that implement the functionality of FieldConvert, thereby giving freedom to customise the order in which modules are used and which command lines options are passed to them. One problem with FieldConvert is when the user wishes to perform the same task on many files; for example converting a number of .chk files to VTK format. To achieve this using FieldConvert, one must run a command like the following $n$ times for each individual file.

%\begin{lstlisting}[style=BashInputStyle]
	%FieldConvert -m session.xml field_n.chk field_n.vtu
%\end{lstlisting}

%These .chk files represent the same fields, only at different moments in time, and so the mesh described in the session file is the same. For each file, an instance of \verb+Field+ is initialised and its member variables populated by the modules \verb+InputFld+, \verb+ProcessCreateExp+, and \verb+OutputVtk+. This is clearly computationally inefficient. In the Python implementation, we are able to initialise instances of these classes only once, and then for each file populate and clear the variables that differ.

\section{User workflow}

The design of the Python interface is to allow the user to instantiate modules by explicitly calling the constructor, register configuration options, and run them. For example, consider the command:

\begin{lstlisting}[style=BashInputStyle]
FieldConvert -n 10 -m wss:bnd=0 session.xml field.fld  field_wss.fld
\end{lstlisting}


A Python script performing the same task is given below.

\begin{lstlisting}[style=C++Style, language=Python]
import sys
from NekPy.FieldUtils import *

field = Field(sys.argv, output_points=10)

InputXml(field, "session.xml").Run()
InputFld(field, "field.fld").Run()
ProcessWSS(field, bnd="0").Run()
OutputFld(field, "field_wss.fld").Run()
\end{lstlisting}

The key points are that the FieldConvert command line options, in this case \inltt{output-points}, are passed to the constructor of \verb+Field+. The configuration options for a given module are passed to the constructor, and the modules can be run immediately after instantiation.


Onr can also emulate the functionality of FieldConvert when using the \inltt{nparts} option in the following way. Here \verb+session_xml+ is a directory containing the mesh partitioned into 2.

\begin{lstlisting}[style=C++Style, language=Python]
import sys
from NekPy.FieldUtils import *

field = Field(sys.argv, nparts = 2)

inputxml = InputXml(field, "session_xml")
inputfld = InputFld(field, "field.fld")
processwss = ProcessWSS(field, bnd="0")
outputfld = OutputFld(field, "field_wss.fld")

for part in range(2):
	field.NewPartition(sys.argv, part);
	inputxml.Run()
	inputfld.Run()
	processwss.Run()
	outputfld.Run()

OutputInfo(field, "field_wss_b0.fld").Run()
\end{lstlisting}


The number of partitions is looped over, with \verb+NewPartition+ called at the start of each. When using \verb+OutputFld+, the \verb+OutputInfo+ module must be used in order to obtain the correct result.

\subsection{Bindings}

\paragraph{Directory structure}

The bindings are stored within a directory named 'Python' in the \texttt{FieldUtils} directory. 
\begin{itemize}
    \item \inlsh{FieldUtils.cpp} is responsible for exporting the \verb+FieldUtils+ Python library.
    \item \inlsh{Field.cpp} contains bindings for the \verb+Field+ struct.
    \item \inlsh{Module.cpp} contains bindings for \verb+Module+, \verb+InputModule+, and \verb+OutputModule+.
    \item \inlsh{InputModules.cpp} contains bindings for the input modules.
    \item \inlsh{ProcessModules.cpp} contains bindings for the process modules.
    \item \inlsh{OutputModules.cpp} contains bindings for the output modules.
\end{itemize}



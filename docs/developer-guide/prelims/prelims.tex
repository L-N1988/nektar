
\chapter{Preliminaries}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Summary of Development Tools}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{General Resources}

\subsubsection{Mailing List}

Please make sure that you sign up for the {\nek} mailing list: \\

\texttt{https://mailman.ic.ac.uk/mailman/listinfo/nektar-users} \\

While it is labeled as a \textit{users} list, this list is also used
to ask questions about {\nek} development.

\subsubsection{Blog}

The {\nek} blog (\texttt{https://www.nektar.info/cat/community})
provides a broad range of posts on topics such as compiling the code
on specific machines, to discussions of {\nek} in specific
application areas, to recently published papers which have made use of
the code.

\subsubsection{Annual Workshop}

In 2015, we held the first {\nek} workshop, which was a great
success and followed by a similar event in 2016. It is now an annual
event and allows first hand access to the core {\nek} development
team as well as a host of other {\nek} users.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Version Control: GIT}

\subsubsection{Anonymous Access}

{\nek} uses the {\GIT} distributed version control system and
is available for anonymous download using this command line (assuming you
have the {\GIT} program installed on your machine): \\

\code{> git clone http://gitlab.nektar.info/clone/nektar/nektar.git nektar++}\\

Until you need to contribute code back to the project, the
only other {\GIT} command you need to know is how to update your
local code with the latest version of the trunk code:\\

\code{> git pull} \\

\subsubsection{Collaborative Access}

However, if you plan to work with the {\nek} community, you will
need to have a reasonable understanding of the {\GIT} version control
software.  While it is beyond the scope of this document to discuss
how to use {\GIT}, it is important for someone new to {\GIT} to spend
time understanding how the tool works.  For this purpose, we highly
recommend familiarizing yourself with it using any of the many online
resources (such as \texttt{https://git-scm.com}). \\

Once you are familiar with {\GIT}, have introduced yourself to the
development community (see the mailing list information above), and
are ready to become a contributing developer, you will need to create
an account on the {\nek} \textit{gitlab} site:
\texttt{https://gitlab.nektar.info}. \\

Code contribution follows three basic steps: 1) Create an
\textit{issue} to describe the code updates you are making, 2)
Branch the {\nek} code trunk and make your changes on that branch,
and 3) Submit a request that your updates be merged into the trunk.
A summary of these steps is found below.  (For more information you may
also refer to: \\

https://gitlab.nektar.info/nektar/nektar/blob/master/CONTRIBUTING.md) \\

\begin{itemize}
\item Issues - The initial step for those who wish to add code to the
  master repository is to creat an \textit{issue} statement that describes the
  proposed additions, changes, updates, etc.  This can be done here: \\
  
  https://gitlab.nektar.info/nektar/nektar/issues.  \\

  Please provide sufficient detail when creating the issue to cover
  all of the following (as required): Describe what is being
  requested, why it is important/necessary, an initial list of files
  that may be effected, any potential problems the change/addition may
  cause, and any other information that will help the development team
  understand the request. \\
  
\item Branches - The second step is to create a {\GIT} branch in which to do
  the actual code developement.  This can be done from the Nektar
  gitlab website: https://gitlab.nektar.info/nektar/nektar/branches
  Press the ``New Branch'' button.  Please see the branch naming
  conventions found here: \\
  https://gitlab.nektar.info/nektar/nektar/blob/master/CONTRIBUTING.md \\
  Once you have created the branch (using the Nektar gitlab site), you
  should check it out to your local machine: \\

\code{> git clone https://gitlab.nektar.info/nektar/nektar.git my\_branch\_id} \\

  Note, in the above command, we have named the directory in which {\GIT}
  will place the code as ``my\_branch\_id''.  However, at this point,
  that directory is still pointing at the repository master. \\

\code{> git status \\
On branch master} \\

  To begin development, you must first switch to the appropriate
  branch: \\

\code{> git checkout my\_branch\_id \\
> git status\\
On branch my\_branch\_id
} \\

  At this point you are all set to make the required modifications to the 
  code in your branch.  As you modify your branch, you can use {\GIT} to
  save and track your changes. \\

  The following examples show how you can add a file to list of local
  files that are being tracked, display differences between the current
  file and the original file, and commit the file.  

\code{> git add library/LibUtilities/BasicUtils/my\_new\_file.cpp} \\
\code{> git diff --cached \# Display any modifcations to the file.} \\

  Note ``--cached'' is necessary because my\_new\_file.cpp was staged using
  the ``git add'' command above.  Note, before you add (stage) the
  file, you can just use ``git diff''. \\

\code{> git commit -m "Added X, Y, Z..."} \\

  Commits the file to your local repository. \\

\code{> git push} \\

  Sends the file to the remote server. \\

  Before you are ready to have your code merged into the {\nek}
  trunk, you should make sure that it passes the built-in test suite -
  in addition to any new tests that you have added for your
  updates. To run the test suite, on the command line type: \\
  
\code{> ctest [-j\#]} \\
  
  The ``-j\#'' optional argument will run ``\#'' tests in parallel
  taking advantage of multiple cores on your machine.  It is highly
  recommended that your use all available cores to minimize the amount
  of time spent waiting for the tests to complete. There are currently
  several hundred built-in unit tests for {\nek}. \\

  For more information on testing, see ``Software Testing Approaches'' below.

  Once all of your modifications have been implemented, tested, and
  committed to your branch, it will be time to move on to the final
  step. \\

\item Merge Requests - The final step in contributing your code to the
  Nektar master repository is to submit a merge request to the
  development team using the {\nek} gitlab website: \\
  
\code{https://gitlab.nektar.info/nektar/nektar/merge\_requests} \\
  
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Managing the Build Process: CMake}

{\nek} uses the \textit{CMake} tool to manage the build process for
the three supported operating systems: Linux, Windows, and OSX.  For
detailed instructions on how to use \textit{CMake} to build {\nek},
including a list of required software dependencies and \textit{CMake}
option flags, please refer to the {\nek} User Guide section 1.3.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{C++11 Features}

This section highlights some of the C++ features that are used
extensively within {\nek}. While much of the code consists of
standard C++ practices, in some of the core infrastructure there are
serveral practices that may be only familiar to programmers who have
developed code using very advanced C++ features.  Below we give a
short summary of these features in order to provide a starting point
when working with these features. We begin with more well known
features and end with some advanced techiniques.  Note, it is not the
purpose of the following sections to cover in detail each of these
concepts, but instead to give a brief overview of these important
concepts such that the developer may look to other, in depth, sources if
they are not familiar with the concepts.

\begin{itemize}

\item Namespaces - Many C++ software projects place their code in a
  namespace.  However, it is important to note that {\nek} uses two
  nested namespaces in most (but not all) cases.  The top level
  namespaces is always ``Nektar'', with the second level usually
  corresponding to the name of the subdirectory the code exists
  in. For example: \\

\begin{verbatim}
  namespace Nektar
  {
    namespace StdRegions
      {
        ...
      }
  }
\end{verbatim}

  With this in mind, when you see something like
  ``Nektar::SpatialDomains::...'', you can usually assume that the
  second item (in this case ``SpatialDomains'') is a namespace, and
  not a class.

\item C++ Standard Template Library (STL) - {\nek} uses of the C++
  STL extensively.  This consists of common classes such as map and
  vector, and also, with the move to C++11, many of the extensions once found
  in the Boost library that have become part of the C++ standard and are
  now used directly.  One of the most important of these features is
  the use of Shared Pointers (shared\_ptr).  Most developers are
  somewhat familiar with ``smart pointers'' (pointers used to track
  memory allocation and to automatically deallocate the memory when it
  is nolonger being used) for data blocks that are shared by multiple
  objects. These smart pointers are used extensively in {\nek} and
  one should be familiar with the ``dynamic\_pointer\_cast'' function
  and the concept of ``weak\_ptr''s.  Dynamic casting allows for safely
  converting one type of variable into its base type (or vice
  versa). For example: \\

\begin{verbatim}
  std::shared_ptr<FilterCheckpointCellModel> sptr =
            std::dynamic_pointer_cast<FilterCheckpointCellModel>( m_filters[k] );
  if( sptr != nullptr ) 
  { 
     // Cast succeeded!
  }
\end{verbatim}

  The advantage of using the dynamic cast, in comparison to the C style
  cast, is that you can check the return value at run time to verify
  that the casting was valid.  A ``weak\_ptr'' is a pointer to shared
  data with the explicit contract that the weak pointer does not own
  the data (and thus will not be responsible for deallocating it).
  Weak pointers are used mostly for short term access to shared data.

  Another modern code utility used by {\nek} to support shared
  pointers can be seen in {\nek} classes when they inherit from
  ``std::enable\_shared\_from\_this''.  This is necessary for any
  class that is to be managed by C++ smart pointers, and allows the
  use of the class' (inherited) function ``shared\_from\_this()'' which
  returns a shard pointer to the class object.

  While C++ shared pointers are a powerful resource, there are a
  number of intricacies that must be understood and followed when
  creating classes and using objects that will be managed by them.
  For those not familiar with the C++11 (or previously Boost)
  implementation, it is highly recommended that you study them in more
  detail then presented here.
  
\item typedefs - Like most other large code basis, {\nek} uses
  ``typedefs'' to create names for new variable types.  You will
  see examples of this throughout the code and taking a few minutes to
  look at the definitions will help make it easier to follow the code.
  In the following example, we create (and explicitly name) the type
  ``ExpansionSharedPtr'' to make the code that uses this type easier
  to follow.

\begin{verbatim}
   typedef std::shared\_ptr<Expansion> ExpansionSharedPtr;
\end{verbatim}

  If you are not familiar with the use of typedefs, you should take
  time to read about them (there are many short summaries
  available on the web).

\item Forward Declarations - There are two ways that an existing class
  type can be used when creating a new class in a header file.  The
  existing class can either be declared, or completely defined by the
  time that it is needed.  In other words, if all that is needed in
  the new class is a variable of the type of the existing class, then
  the existing class must only be declared.  If functions on that
  variable must be called (within the new header file), then the
  existing class must be fully defined by the point it is used.  In
  order to reference a class in a header file, only the name of the
  class must be known to the compiler at the point it is to be
  referenced, but to use the existing class (actually call functions
  on an object of the class' type) the class must be defined. \\

  The reason to just reference the class is that the header file does
  not need to \#include the entire existing class.  This allows for
  cleaner header files and faster compilations.  The method in which
  one allows for the existing class to be referenced (without
  \#including it) is to ``Forward Declare'' the class.  This is done
  toward the top of the new class file in this manner: \\

\begin{verbatim}
    class LinearSystem; \# Forward declare this class.
\end{verbatim}

  In this example, the compiler is told that there exists a class
  ``LinearSystem'', but at this point the compiler does not need further
  details.  In the new class' header file, you can then create
  variables (or use them as parameters to functions) of this existing
  class (``LinearSystem'') type.
  
\item Templated Classes and Specialization - Most C++ developers are
  familiar with basic class templating.  However, many have not needed
  to use explicit template specialization.  This is the process of
  implementing one or more of the specific versions of a template when
  the compiler will not be able to instantiate a generic version for
  the class, or when different code is needed based on different
  versions of the class.  For example:

\begin{verbatim}
  template<typename Dim, typename DataType> class Array; \\
  template<typename DataType> class Array<OneD, const DataType> { \\
    // Explicit coding of class methods and variables specific to \\
    // this version of Array are found here. \\
  };
\end{verbatim}

  In the above example, on the first line the generic templated
  ``Array'' class is declared.  The second line shows an explicit
  instantiate of the Array class for a one dimensional (version of)
  ``Array''.  When explicitly instantiating a class, the programmer
  will write code that is specific to the datatype used in specifying
  the class.  This includes explicitly writing code for one, some, or
  all of the methods of the class. \\

  It is important to understand template specialization when dealing
  with the {\nek} core libraries so that the developer can
  determine which (specialized version of the) class is being used,
  and to know that when updating classes with varied specializations,
  that it may be required to update code in several places (ie, for
  each of the specializations).

\item Multiple Inheritance and the ``virtual'' Keyword - When diving
  into many {\nek} classes, you will see the use of multiple
  inheritance (where a class inherits from more than one parent
  class).  When the parent class does not inherit from other classes,
  then the inheritance is straigtforward and should not cause any
  confusion.  However, when a class has grandparents, many times that
  grandparent class is the same class but is inherited through multiple
  parents.  To account for this, class inheritance should use the
  ``virtual'' keyword.  This specifies that if a class has multiple
  grandparents (that happen to be the same class), that only one of
  them should actually be instantiated.  For example: \\

\begin{verbatim}
class Expansion2D : virtual public Expansion, virtual public StdRegions::StdExpansion2D
\end{verbatim}

In the above example, if parent classes ``Expansion'' and
``StdExpansion2D'' both inherit from a shared grand parent, then the
class ``Expansion2D'' (without the ``virtual'' keyword) would have two
copies of the grandparent class, leading to strange and hard to debug
issues in the code.  Fortunately this is easily avoided by using (as
seen above) the ``virtual'' keyword when specifying the inheritance hierarchy.

\item Virtual Functions and Inheritance - Within {\nek}, classes
  that inherit from a parent class and override one of the parent
  class methods, use the ``v\_Function()'' naming convention.  This is a
  visual reminder that the function overrides a parent class function.
  Additionally, at the top level parent class you will find
  ``Function()''.  As an example of this, let us consider a triangle
  element (``TriExp'').  The ``TriExp'' class (eventually) inherits
  from the ``StdExpansion'' class.  The ``StdExpansion'' has the
  ``Integral()'' function which is used to provide integration over
  an element.  However, the only thing the
  ``StdExpansion::Integral()'' function does is call the (in this case)
  ``TriExp::v\_Integral()'' function.  We should also note that while
  ``TriExp::v\_Integral()'' does setup work, it then makes use of its parent's
  ``StdExpansion2D::v\_Integral()'' function to calculate the final value.

\code{NekDouble TriExp::v\_Integral(const Array<OneD, const NekDouble> \&inarray)}

\item Const keyword - While the ``const'' keyword is known to most C++
  developers, it is used (as it should be) liberally in {\nek} for
  function parameters, returning pointers to class data, and variable
  constants within functions.  It is easy to neglect using ``const''
  to mark all cases where a variable should be considered constant. If
  code is carefully written and correctly written, then marking a
  variable ``const'' will not be required for correct code execution.
  However, its use can substantially reduce accidental errors and
  allow for accelerated debugging.  ``Const'' should be used wherever
  a variable does not change including 1) parameters passed to
  functions, 2) variables in functions (or classes) that do not change
  value, 3) on the return type of functions that return pointers to
  data that should not be changed, and 4) on methods that do not
  change data within the class.

\item Function pointers and bind - Function pointers
  (``std::function'') are similiar to pointers to data, except that
  they point to functions - and thus allow a function to be invoked
  indirectly (in other words, without explicilty writing the function
  call (name) directly in code).  This technique is used by {\nek}
  in a number of places, with ``NekManager'' being a prime example.
  The ``NekManager'' class is used to create objects of a specific
  type during the execution of the program.  When a ``NekManager'' is
  created (constructed), it is provied with a pointer to the function
  that will (later) be called to generate the required data.  While
  the ``creation'' function that is provided to the ``NekManager''
  takes a number of parameters, in many cases some of the values to
  those parameters will be fixed.  To handle this situation, {\nek}
  uses the ``std::bind( f )'' function, which creates a new function
  based on supplied original function ``f'', but specifies that one
  or more parameters of ``f'' are fixed at the time that ``f''' is
  created and only those bound parameter values will be used when
  ``f''' is later invoked.  
  
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Factory Pattern}

{\nek} makes extensive use of the ``Factory Pattern''.
``Factories'' are objects used to create (ie: allocate) other objects
(See the short discussion of ``NekManager'' above).  More
specifically, a ``Factory'' will create a new object of some
``sub-class'' type but return a ``base class'' pointer for the new
object. In general, there are two ways that a ``Factory'' knows what
specific type of object to generate: 1) The ``Factory'''s build
function ({\nek} uses the factory function ``CreateInstance()'') is
passed some information that details what to build; or 2) The factory may
have some intrinsic knowledge detailing what objects to create. 
Factory pattenrs provides the following benefits:
\begin{itemize}
\item Encourages modularisation of code such that conceptually related
algorithms are grouped together
\item Structuring of code such that different implementations of the same
concept are encapsulated and share a common interface
\item Users of a factory-instantiated modules need only be concerned with the
 interface and not the details of underlying implementations
\item Simplifies debugging since code relating to a specific implementation
 resides in a single class
\item The code is naturally decoupled to reduce header-file dependencies and
 improves compile times
\item Enables implementations (e.g. relating to third-party libraries) to be
 disabled through the build process (CMake) by not compiling a specific 
 implementation, rather than scattering preprocessing statements throughout the
 code
\end{itemize}


%% Because {\nek} uses many factory types throughout the code base, a
%% templated version has been implemented to provide the required
%% functionality for these various factories.  The template code for
%% this class can be found in:

%% \code{LibUtilities/BasicUtils/NekFactory.hpp} \\

%% An example of the use of a {\nek} factory can be found in: \\

%% \code{library/NekMeshUtils/VolumeMeshing/VolumeMesh.cpp} \\

%% Specifically, in ``VolumeMesh::Process()'' the ``CreateInstance()'' function is used
%% to create quadrilaterals.

\subsection{Using NekFactory}
The templated NekFactory class implements the factory pattern in Nektar++.
There are two distinct aspects to creating a factory-instantiated collection of
classes: defining the public interface, and registering specific
implementations. Both of these involve adding standard boilerplate code. It is
assumed that we are writing a code which implements a particular concept or
functionality within the code, for which there are multiple implementations. The
reasons for multiple implementations may be very low level such as alternative
algorithms for solving a linear system, or high level, such as selecting from a
range of PDEs to solve.

\subsubsection{Creating an interface (base class)}
A base class must be defined which prescribes an implementation-independent
interface. In Nektar++, the template method pattern is used, requiring public
interface functions to be defined which call private virtual implementation
methods. The latter will be overridden in the specific implementation classes.
In the base class these virtual methods should be defined as pure virtual, since
there is no implementation and we will not be instantiating this base class
explicitly.

As an example we will create a factory for instantiating different
implementations of some concept \inlsh{MyConcept}, defined in
\inlsh{MyConcept.h} and \inlsh{MyConcept.cpp}. First in \inlsh{MyConcept.h},
we need to include the NekFactory header

\begin{lstlisting}[style=C++Style]
#include <LibUtilities/BasicUtils/NekFactory.hpp>
\end{lstlisting}

The following code should then be included just before the base class
declaration (in the same namespace as the class):

\begin{lstlisting}[style=C++Style]
class MyConcept

// Datatype for the MyConcept factory
typedef LibUtilities::NekFactory< std::string, MyConcept, 
            ParamType1,
            ParamType2 > MyConceptFactory;
MyConceptFactory& GetMyConceptFactory();
\end{lstlisting}

The template parameters define the datatype of the key used to retrieve a
particular implementation (usually a string, enum or custom class such as
\inlsh{MyConceptKey}, the base class (in our case \inlsh{MyConcept} and a list
of zero or more parameters which are taken by the constructors of all
implementations of the type \inlsh{MyConcept} (in our case we have two). Note
that all implementations must take the same parameter list in their constructors.

The normal definition of our base class then follows:

\begin{lstlisting}[style=C++Style]
class MyConcept 
{
    public:
        MyConcept(ParamType1 p1, ParamType2 p2);
        ...
};
\end{lstlisting}

We must also define a shared pointer for our base class for use later
\begin{lstlisting}[style=C++Style]
typedef boost::shared_ptr<MyConcept> MyConceptShPtr;
\end{lstlisting}

\subsubsection{Creating a specific implementation (derived class)}
A class is defined for each specific implementation of a concept. It is these
specific implementations which are instantiated by the factory.

In our example we will have an implementations called \inlsh{MyConceptImpl1}
defined in \inlsh{MyConceptImpl1.h} and \inlsh{MyConceptImpl1.cpp}. In the
header file we include the base class header file

\begin{lstlisting}[style=C++Style]
#include <Subdir/MyConcept.h>
\end{lstlisting}

We then define the derived class as normal:

\begin{lstlisting}[style=C++Style]
class MyConceptImpl1 : public MyConcept
{
...
};
\end{lstlisting}

In order for the factory to work, it must know
\begin{itemize}
\item that {{{MyConceptImpl1}}} exists, and
\item how to create it.
\end{itemize}

To allow the factory to create instances of our class we define a function in 
our class:
\begin{lstlisting}[style=C++Style]
/// Creates an instance of this class
static MyConceptSharedPtr create(
            ParamType1 p1,
            ParamType2 p2)
{
    return MemoryManager<MyConceptImpl1>::AllocateSharedPtr(p1, p2);
}
\end{lstlisting}
This function simply creates an instance of \inlsh{MyConceptImpl1} using the
supplied parameters. It must be \inlsh{static} because we are not operating on
an existing instance and it should return a base class shared pointer (rather 
than a \inlsh{MyConceptImpl1} shared pointer), since the point of the factory
is that the calling code does not know about specific implementations.

The last task is to register our implementation with the factory. This is done 
using the \inlsh{RegisterCreatorFunction} member function of the factory.
However, we wish this to happen as early on as possible (so we can use the 
factory straight away) and without needing to explicitly call the function for 
every implementation at the beginning of our program (since this would again 
defeat the point of a factory)! The solution is to use the function to 
initialise a static variable: it will be executed prior to the start of the
\inlsh{main()} routine, and can be located within the very class it is
registering, satisfying our code decoupling requirements.

In \inlsh{MyConceptImpl1.h} we define a static variable with the same datatype
as the key used in our factory (in our case \inlsh{std::string}) 
\begin{lstlisting}[style=C++Style]
static std::string className;
\end{lstlisting}
The above variable can be \inlsh{private} since it is typically never actually
used within the code. We then initialise it in \inlsh{MyConceptImpl1.cpp}

\begin{lstlisting}[style=C++Style] 
string MyConceptImpl1::className
        = GetMyConceptFactory().RegisterCreatorFunction(
                                "Impl1", 
                                MyConceptImpl1::create, 
                                "First implementation of my concept.");
\end{lstlisting}
The first parameter specifies the value of the key which should be used to
select this implementation. The second parameter is a function pointer to our
static function used to instantiate our class. The third parameter provides a
description which can be printed when listing the available MyConcept
implementations.

\subsection{Instantiating classes}
To create instances of MyConcept implementations elsewhere in the code, we must
first include the ''base class'' header file
\begin{lstlisting}[style=C++Style]
#include <Subdir/MyConcept.h>
\end{lstlisting}
Note we do not include the header files for the specific MyConcept 
implementations anywhere in the code (apart from \inlsh{MyConceptImpl1.cpp}).
If we modify the implementation, only the implementation itself requires 
recompiling and the executable relinking.

We create an instance by retrieving the \inlsh{MyConceptFactory} and call the
\inlsh{CreateInstance} member function of the factory:
\begin{lstlisting}[style=C++Style]
ParamType p1 = ...;
ParamType p2 = ...;
MyConceptShPtr p = GetMyConceptFactory().CreateInstance( "Impl1", p1, p2 );
\end{lstlisting}

Note that the class is used through the pointer \inlsh{p}, which is of type
\inlsh{MyConceptShPtr}, allowing the use of any of the public interface
functions in the base class (and therefore the specific implementations behind them) to be
called, but not directly any functions declared solely in a specific
implementation.


\section{NekArray}
An Array is a thin wrapper around native arrays. Arrays provide all the
functionality of native arrays, with the additional benefits of automatic use of
the Nektar++ memory pool, automatic memory allocation and deallocation, bounds
checking in debug mode, and easier to use multi-dimensional arrays.

Arrays are templated to allow compile-time customization of its dimensionality
and data type.

Parameters:
\begin{itemize}
\item \inltt{Dim} Must be a type with a static unsigned integer called
\inltt{Value} that specifies the array's dimensionality. For example
\begin{lstlisting}[style=C++Style]
struct TenD {
    static unsigned int Value = 10;
};
\end{lstlisting}
\item \inltt{DataType} The type of data to store in the array.
\end{itemize}

It is often useful to create a class member Array that is shared with users of
the object without letting the users modify the array. To allow this behavior,
Array<Dim, !DataType> inherits from Array<Dim, const !DataType>. The following
example shows what is possible using this approach:
\begin{lstlisting}[style=C++Style]
 class Sample {
     public:
         Array<OneD, const double>& getData() const { return m_data; }
         void getData(Array<OneD, const double>& out) const { out = m_data; }

     private:
         Array<OneD, double> m_data;
 };
\end{lstlisting}
In this example, each instance of Sample contains an array. The getData
method gives the user access to the array values, but does not allow
modification of those values.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Software Testing Approaches}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unit Tests}

Unit testing, sometimes called ``module testing'' or ``element testing'', is a
software testing method by which individual ``units'' of source code
are tested to determine whether they are fit for use
\cite{KFN-testing}.  Unit tests are added to {\nek} through the
CMake system, and implemented using the Boost test framework.
As an example, the set of linear algebra unit tests is
listed in this file: \\

.../library/UnitTests/LibUtilities/LinearAlgebra/CMakeLists.txt \\

and the actual tests are implemented in this file: \\

.../library/UnitTests/LibUtilities/LinearAlgebra/TestBandedMatrixOperations.cpp \\

To register a new test, you use ``BOOST\_AUTO\_TEST\_CASE( TestName )'',
implement the unit test, and test the result using
``BOOST\_CHECK\_CLOSE(...)'', ``BOOST\_CHECK\_EQUAL(...)'', etc. Unit
tests are invaluable in maintaining the integrety of the code base and
for localizing, finding, and debugging errors entered into the code. It is
important to remember a unit test should test very specific
functionality of the code - in the best case, a single function should be
tested per unit test. \\

While it is beyond the scope of this document to go into more detail
on writing unit tests, a good summary of the Boost test system can be
found here: http://www.boost.org/doc/libs/1\_63\_0/libs/test/doc/html/.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Functional (Regression) Tests}
Functional testing, which in {\nek} we refer to as {\em regression testing},
is the testing of software components based upon expected
behavior.  It is not ``white-box'' in that it does not examine how the
code arrives at a particular answer, but rather in a ``black-box''
fashion tests to see if code when operating on certain data yields the
predicted response \cite{KFN-testing}.

{\nek} uses a web-enabled ``buildbot'' site to show the results of
recent test runs on multiple operating systems.  The ``buildbot''
system can be used to manually instigate a {\nek} system test on a
development branch of code.  For more information, go to:

\code{http://buildbot.nektar.info}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\input{prelims/coding-standard.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

